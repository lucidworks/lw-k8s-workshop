== Lab 3: Exploring Kubernetes Deployments

In this lab, you'll apply what you learned about Kubernetes deployments to understand how the Fusion query pipeline service works.
You'll also get a feel for how Helm works behind the scenes to deploy objects into Kubernetes.

=== Step 1: Explore Fusion Objects

Spend a few minutes exploring the pods, deployments, services, secrets, and configmaps in the Fusion cluster.

[width="80%",cols="3,5",options="header"]
|=========================================================
|Action|Command
|List pods in namespace|k get po
|List pods and nodes|k get po -o wide
|List deployments|k get deploy
|List services|k get svc
|List statefulsets|k get sts
|List config maps|k get cm
|=========================================================

=== Step 2: Fetch the Fusion Helm Chart and Render Locally

List the Helm chart repositories registered to your local Helm client:
```
helm repo list
```

Fetch the latest Fusion 5 Helm chart from our Helm repo and extract it locally:
```
helm fetch lucidworks/fusion --version 5.0.3-2 --untar
```
Spend a few minutes exploring the `fusion` directory.

Use `helm template` command and the custom values yaml (`lab3_custom_values.yaml`) to render the chart into a Kubernetes deployment manifest locally:
```
helm template "LAB3" fusion/charts/query-pipeline --namespace "LAB3-NS" --values lab3_custom_values.yaml > explore_qp.yaml
```
`LAB3` is the Helm "release" label. When you installed your cluster, the setup script used the namespace for the release, which is a good practice to use in k8s clusters that run multiple Fusion namespaces.

Explore the Kubernetes objects in the `explore_qp.yaml` file we just created; take notice of where the "LAB3" release value is used, as well as the "LAB3-NS" namespace value.

To guide your exploration, look for the various objects we discussed in this lesson:

* docker image
* deployment & pod spec
* configmap(s)
* secrets
* liveness / readiness probes
* labels / annotations
* service
* service accounts

=== Step 3: Kill a pod manually

Now, let's turn our attention back to the cluster to work with the deployed query pipeline service. Start by killing the query pod manually. You'll have to lookup the ID of the query pod using `k get pods`

```
kubectl delete po <ID> --force --grace-period 0
```

What happens?


TODO:

=== Step 7: Upgrade to Latest Fusion 5.0.3-2

The setup script created a custom values yaml file and a new shell script named `gke_${LW_K8S_CLUSTER}_${LW_K8S_NAMESPACE}_fusion_upgrade.sh` in the `fusion-cloud-native` directory.

Edit the update script to set the `CHART_VERSION` variable in your upgrade to `5.0.3-2` (the latest version) and run the upgrade script to upgrade your cluster to the latest updates for 5.0.2

Watch the pods as the upgrade rolls out across the cluster. `kubectl get pods --watch`.

Check the Docker image versions running in the namespace using:
```
kubectl get po -o jsonpath='{..image}'  | tr -s '[[:space:]]' '\n' | sort | uniq
```

If you notice the admin service does not come up successfully after running the upgrade, you can kill it `k delete po <ID>`.
This is due to a minor bug in the admin service when only running 1 Solr pod, the admin service can get hung if Solr upgrades at the same time as the admin service.


=== Step 4: Scale the query pipeline service up and down

Use kubectl to scale the `${LW_K8S_RELEASE}-query-pipeline` deployment up and down

Up:
```
k scale deployment ${LW_K8S_RELEASE}-query-pipeline --replicas=2
```

Observe K8s behavior while scaling:
```
k get pods --watch
```

Down:
```
k scale deployment ${LW_K8S_RELEASE}-query-pipeline --replicas=1
```

Be sure to scale back down to 1 before proceeding to the next step

=== Step 5: Verify your pod is serving traffic

Send a request to the query pod via the api-gateway:
```
curl -u admin:<PASSWORD> "http://${LW_K8S_GATEWAY_IP}:6764/api/apps/lab1/query/lab1?q=*:*"
```
Remember you can get the IP for the gateway using:
```
kubectl --namespace ${LW_K8S_NAMESPACE} get service proxy -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
```

Did you know every Fusion microservice exposes Swagger API documentation? Try loading this URL in your browser:
```
open "http://${LW_K8S_GATEWAY_IP}:6764/query/swagger-ui.html"
```

__All Fusion microservices that support public APIs expose Swagger documentation similar to the query service.__

=== Step 6: Try to send a request to a query pod directly

Let's bypass the Fusion API gateway and send a request directly to the query service.

Open a port-forward to a query pod and try to execute a query request against it ... what happens?

__Tip: You need to figure out what port the query pod listens on before you can establish a port-forward.__

Once you have a port-forward open, send this request (set the `<PORT>` correctly first):
```
curl "http://localhost:<PORT>/query-pipelines/lab1/collections/lab1/select?q=*:*"
```

The request should fail with a 401 error. If you take the JWT and send it back in the Authorization header (Bearer scheme), such as:
```
curl -H "Authorization: Bearer <JWT>" "http://localhost:<PORT>/query-pipelines/lab1/collections/lab1/select?q=*:*"
```
The request should succeed.